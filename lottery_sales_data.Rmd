---
title: "R Notebook"
output: html_notebook
---

# --- Settings ---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# --- Packages ---

```{r}
library(readxl)
library(tidyverse)
library(binom)

```

# --- Load Data ---

## 1. read

```{r}
lott <- read_xlsx("lottery_sales_data.xlsx")

```

## 2. view

```{r}
View(lott)
```

## 3. types

```{r}
# examine cols&types
t(data.frame(lapply(lott, class)))
```


# --- Analysis ---

# 1. Basic Shaping & Viz

## 1.1. shape

```{r}
lott_clean <-
lott %>% 
  mutate(jackpot = jackpot * 1000000,
         sales = sales_mm + sales_jj)

lott_clean
```

## 1.2. graph: just jackpot

```{r, fig.height=5, fig.width=15}
ggplot(data = lott_clean,
       aes(x = date,
           y = jackpot)) +
  geom_point() +
  geom_line()

```

# 1.3. jackpot quantiles (in millions)

```{r}
quantile(round(lott_clean$jackpot/1e6, digits = 1), probs = c(0, 0.01, 0.05, seq(0.1, 0.9, 0.1), 0.95, 0.99, 1))
```

## 1.4. graph: sales

```{r, fig.height=5, fig.width=15}
ggplot(data = lott_clean,
       aes(x = date,
           y = sales)) +
  geom_point() +
  geom_line()

```

## 1.5. sales quantiles (in millions)

```{r}
quantile(round(lott_clean$sales/1e6, digits = 1), probs = c(0, 0.01, 0.05, seq(0.1, 0.9, 0.1), 0.95, 0.99, 1))
```


# 2. Sales & Jackpot Combined

Very useful resource, for dual y-axis graphs
https://www.r-graph-gallery.com/line-chart-dual-Y-axis-ggplot2.html

Very useful resource for date formatting in ggplot
https://www.r-graph-gallery.com/279-plotting-time-series-with-ggplot2.html

## 2.1. graph: w/ outlier

```{r, fig.height=7, fig.width=15}
coeff <- max(lott_clean$jackpot)/max(lott_clean$sales)
color_jackpot <- "green3"
color_sales <- "black"

plot_2c <-
lott_clean %>% 
ggplot(aes(x = as.Date(date))) +
  geom_line(aes(y = jackpot),
            color = color_jackpot,
            size = 2,
            alpha = 0.5) +
  geom_line(aes(y = sales * coeff),
            color = color_sales,
            size = 1,
            alpha = 0.5) +
  scale_x_date(name = "Date",
               date_labels = "%Y (%b)",
               date_breaks = "1 month") +
  scale_y_continuous(labels = scales::label_dollar(),
                     breaks = c(0, 1:16*100e6),
                     name = "Jackpot Value",
                     sec.axis = sec_axis(trans = ~.*(1/coeff),
                                       name = "Tickets Sold",
                                       breaks = c(0, seq(0, 8, 0.5)*100e6),
                                       labels = scales::comma)) +
  labs(title = "Jackpot Size & Ticket Sales, Over Time") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y.left = element_text(color = color_jackpot, size = 10),
        axis.title.y.left = element_text(color = color_jackpot),
        axis.title.y.right = element_text(margin = margin(t = 0, r = 0, b = 0, l = 10)),
        axis.text.x = element_text(angle = 90))

plot_2c

```

## 2.1. save

```{r}
ggsave(plot = plot_2c,
       filename = "jackpot_sales_full.pdf",
       width = 15,
       height = 7)
```


## 2.2. graph: w/o outlier

```{r, fig.height=7, fig.width=15}
coeff <- 3.5 #max(lott_clean$jackpot)/max(lott_clean$sales)
color_jackpot <- "green3"
color_sales <- "black"

plot_2d <-
lott_clean %>% 
ggplot(aes(x = as.Date(date))) +
  geom_line(aes(y = jackpot),
            color = color_jackpot,
            size = 2,
            alpha = 0.5) +
  geom_line(aes(y = sales * coeff),
            color = color_sales,
            size = 1,
            alpha = 0.5) +
  scale_x_date(name = "Date",
               date_labels = "%Y (%b)",
               date_breaks = "1 month") +
  scale_y_continuous(labels = scales::label_dollar(),
                     breaks = c(0, 1:16*100e6),
                     limits = c(0, 625e6),
                     name = "Jackpot Value",
                     sec.axis = sec_axis(trans = ~.*(1/coeff),
                                       name = "Tickets Sold",
                                       breaks = c(0, seq(0, 200, 10)*1e6),
                                       labels = scales::comma)) +
  labs(title = "Jackpot Size & Ticket Sales, Over Time") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y.left = element_text(color = color_jackpot, size = 10),
        axis.title.y.left = element_text(color = color_jackpot),
        axis.title.y.right = element_text(margin = margin(t = 0, r = 0, b = 0, l = 10)),
        axis.text.x = element_text(angle = 90))

plot_2d
```


## 2.2. save

```{r}
ggsave(plot = plot_2d,
       filename = "jackpot_sales_exclude.pdf",
       width = 15,
       height = 7)
```


# 3. Split Pot

## 3.1. function: calculate odds of split pot

inputs:
-- number of potential winners
-- number of tickets sold
-- probability of winning jackpot
output:
-- odd of this many people splitting the pot

formula/calculations from here:
http://www.durangobill.com/MegaMillionsOdds.html

```{r}
prob_k <- function(num_winners, num_tickets, prob_win){
  #return(choose(n = num_tickets, k = num_winners) * prob_win^num_winners * (1-prob_win)^(num_tickets-num_winners))
  return(dbinom(size = num_tickets, x = num_winners, prob = prob_win)) #(same as above)
}
```

## 3.1 test

```{r}
print("---1---")
(1/302575350)
print("---2---")
prob_k(num_winners = 1, num_tickets = 1, prob_win = (1/302575350))
prob_k(num_winners = 1, num_tickets = 2, prob_win = (1/302575350))
print("---3---")
prob_k(num_winners = 1, num_tickets = 2, prob_win = (1/302575350))/prob_k(num_winners = 1, num_tickets = 1, prob_win = (1/302575350))
prob_k(num_winners = 1, num_tickets = 3, prob_win = (1/302575350))/prob_k(num_winners = 1, num_tickets = 1, prob_win = (1/302575350))
prob_k(num_winners = 1, num_tickets = 4, prob_win = (1/302575350))/prob_k(num_winners = 1, num_tickets = 1, prob_win = (1/302575350))
print("---4---")
prob_k(num_winners = 2, num_tickets = 2, prob_win = (1/302575350))/prob_k(num_winners = 2, num_tickets = 2, prob_win = (1/302575350))
prob_k(num_winners = 2, num_tickets = 3, prob_win = (1/302575350))/prob_k(num_winners = 2, num_tickets = 2, prob_win = (1/302575350))
prob_k(num_winners = 2, num_tickets = 4, prob_win = (1/302575350))/prob_k(num_winners = 2, num_tickets = 2, prob_win = (1/302575350))
```


## 3.2. function: expected value, incorporating odds of split pot

inputs:
-- jackpot size (can be either cash value or annuity value)
-- number of tickets sold
-- max number of potential winners to consider
-- probability of winning jackpot
-- (also: method of computing probability, summing or inverse of non-winners)
-- (also: whether pot is to be split)
outputs:
-- expected value of a ticket (incorporating odds and payout if split ticket)

```{r}
ev_split <- function(jackpot, tickets, max_winners, prob_win, method, split){
  
  # 
  if (method == "inverse" & split == TRUE){
    ev <- jackpot * (1 - prob_k(num_winners = 0, num_tickets = tickets, prob_win = prob_win))
  }
  
  if (method == "inverse" & split == FALSE){
    return("nah, this combo (inverse & no split) doesn't make sense")
  }
  
  if (method == "sum"){
    ev <- 0
    for (n in 1:max_winners){
      if (split == TRUE){
      ev <- ev + ((jackpot/n)*n * prob_k(num_winners = n, num_tickets = tickets, prob_win = prob_win))
      #ev <- ev + ((jackpot/n)*n * dbinom(size = n, x = tickets, prob = prob_win)) #(same as above)
      }
      if (split == FALSE){
      ev <- ev + ((jackpot/1)*n * prob_k(num_winners = n, num_tickets = tickets, prob_win = prob_win))
      }
    }
  }
  
  return(ev/tickets)
  
}

```


## 3.2. test

```{r}
print("---1---")
850e6*(1/302575350)
print("---2---")
t1 <- Sys.time()
ev_split(jackpot = 850e6, tickets = 1, max_winners = 1, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 2, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 5, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 100, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 1e6, prob_win = (1/302575350), method = "sum", split = TRUE)
Sys.time() - t1
print("---3---")
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 1, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
print("---4---")
ev_split(jackpot = 400e6, tickets = 300e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
# check against: http://www.durangobill.com/MegaMillionsOdds.html
0.8386
400e6*(1-prob_k(num_winners = 0, num_tickets = 300e6, prob_win = (1/302575350)))/300e6
print("---5---")
t1 <- Sys.time()
ev_split(jackpot = 850e6, tickets = 1, max_winners = 1, prob_win = (1/302575350), method = "inverse", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 2, prob_win = (1/302575350), method = "inverse", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 5, prob_win = (1/302575350), method = "inverse", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 10, prob_win = (1/302575350), method = "inverse", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 100, prob_win = (1/302575350), method = "inverse", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1, max_winners = 1e6, prob_win = (1/302575350), method = "inverse", split = TRUE)
Sys.time() - t1
print("---6---")
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 1, prob_win = (1/302575350), method = "inverse", split = TRUE)
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 10, prob_win = (1/302575350), method = "inverse", split = TRUE)
print("---7---")
ev_split(jackpot = 400e6, tickets = 300e6, max_winners = 10, prob_win = (1/302575350), method = "inverse", split = TRUE)
print("---8---")
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 1, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 2, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 5, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 200e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
print("---9---")
ev_split(jackpot = 400e6, tickets = 300e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
print("---10---")
ev_split(jackpot = 400e6, tickets = 300e6, max_winners = 10, prob_win = (1/302575350), method = "inverse", split = FALSE)
print("---11---")
ev_split(jackpot = 850e6, tickets = 1, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 10, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 100, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 1000, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 10e3, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 100e3, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 1e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 10e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 100e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
ev_split(jackpot = 850e6, tickets = 1000e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = FALSE)
print("---12---")
ev_split(jackpot = 850e6, tickets = 1, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 10, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 100, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1000, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 10e3, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 100e3, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 10e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 100e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)
ev_split(jackpot = 850e6, tickets = 1000e6, max_winners = 10, prob_win = (1/302575350), method = "sum", split = TRUE)


```
## 3.3. split pot odds, calculate

calculate odds of split pot, as function of number of tickets sold

Plan:
- loop from 1 million to 1 billion ticket sales, by million
- loop from 0 winners to 10 winners
- calculate the odds of winning, for each combination
- store results

```{r}
# set values to loop through
loop_winners <- 0:10
loop_tickets <- 1:1000*1e6
total_loop <- length(loop_winners) * length(loop_tickets)

# create data frame, to store results
dat_split <- data.frame(num_winners = integer(length = total_loop),
                        num_tickets = integer(length = total_loop),
                        prob = double(length = total_loop))


# loop through all values, calculate odds, and store
index <- 0
for (num_winners_i in loop_winners){
  for (num_tickets_k in loop_tickets){
    index <- index + 1
    
    dat_split$num_winners[index] <- num_winners_i
    dat_split$num_tickets[index] <- num_tickets_k
    dat_split$prob[index] <- prob_k(num_winners = num_winners_i,
                                    num_tickets = num_tickets_k,
                                    prob_win = (1/302575350))
    
  }
}

```

## 3.4. view results (tabular)

```{r}
dat_split
```

## 3.5. prob sums

- we can see that, the first ten winners, even at 1 billion tickets, account for more than 99.9% of winners
- (i.e. we gain little from further incorporating odds of 11, 12, 13+ winners)

```{r}
dat_split %>% 
  arrange(num_tickets, num_winners) %>% 
  group_by(num_tickets) %>% 
  summarize(prob_sum = sum(prob))

```

## 3.6. graph: split pot

```{r, fig.height=6, fig.width=12}
plot_3d <-
dat_split %>%
  filter(num_winners <= 5) %>% 
  mutate(num_winners = as.factor(num_winners)) %>% 
  ggplot(aes(x = num_tickets,
             y = prob,
             color = num_winners)) +
  geom_line(size = 1.25,
            alpha = 0.5) +
  scale_x_continuous(labels = scales::comma,
                     breaks = seq(0, 1000, 100)*1e6) +
  scale_y_continuous(breaks = seq(0, 1, 0.1)) +
  labs(x = "Number of Tickets Sold",
       y = "Probability of This Number of Winners",
       title = "Probability of Various Split Pots \n (Calculations from Bill Butler)",
       color = "Numbers of Winners") +
  annotate("rect",
         xmin = min(lott_clean$sales),
         xmax = quantile(lott_clean$sales, prob = 0.50),
         ymin = 0,
         ymax = 1,
         fill = "blue",
         alpha = 0.2) +
  annotate("rect",
         xmin = min(lott_clean$sales),
         xmax = quantile(lott_clean$sales, prob = 0.90),
         ymin = 0,
         ymax = 1,
         fill = "blue",
         alpha = 0.2) + 
  annotate("rect",
         xmin = min(lott_clean$sales),
         xmax = quantile(lott_clean$sales, prob = 0.99),
         ymin = 0,
         ymax = 1,
         fill = "blue",
         alpha = 0.2) + 
  annotate("text",
           x = quantile(lott_clean$sales, prob = 0.50),
           y = 0.5,
           label = "50th percentile",
           angle = 90,
           size = 4) +
  annotate("text",
         x = quantile(lott_clean$sales, prob = 0.90),
         y = 0.5,
         label = "90th percentile",
         angle = 90,
         size = 4) +
  annotate("text",
       x = quantile(lott_clean$sales, prob = 0.99),
       y = 0.5,
       label = "99th percentile",
       angle = 90,
       size = 4) +
  geom_vline(xintercept = max(lott_clean$sales)) +
  annotate("text",
           x = max(lott_clean$sales) + 5e6,
           y = 0.5,
           label = "maximum sales ever",
           angle = 90,
           size = 4) +
  geom_vline(xintercept = min(lott_clean$sales)) +
  annotate("text",
           x = min(lott_clean$sales) - 10e6,
           y = 0.5,
           label = "minimum sales ever",
           angle = 90,
           size = 4) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 0),
        plot.title = element_text(hjust = 0.5))

plot_3d
```

## 3.6. save

```{r}
ggsave(plot = plot_3d,
       filename = "split_pot_overlay.pdf",
       width = 15,
       height = 7)
```


# 4. Cash Value

The goal here is to figure out the cash value of various jackpots, from their advertised (i.e. annuity) amounts.
Can't find a super clear answer (at least to me on this). Below are the more details written state rules/laws for the lottery.
- https://vtlottery.com/sites/default/files/pdf/Rules-MM%202017-10.pdf
- https://static.coloradolottery.com/media/filer_public/26/2f/262feb46-6929-4707-969a-5d2b210b4d90/rule_14c_-_mega_millions.pdf 

But honestly, I don't really understand these, so will just look at historical records of jackpot size, and compare advertised (annuity) amount of the jackpot, to the stated equivalent cash prize.

Used, wayback machine for this:
- 2021: https://web.archive.org/web/20210101000000*/https://www.megamillions.com/
- 2020: https://web.archive.org/web/20200315000000*/https://www.megamillions.com/
- 2019: https://web.archive.org/web/20190115000000*/https://www.megamillions.com/
- 2018: https://web.archive.org/web/20180701000000*/https://www.megamillions.com/
- 2017: https://web.archive.org/web/20170701000000*/https://www.megamillions.com/

(Seems like the date of the screenshots are kind of out of wack with the date of the drawing. But when you click on the link, it gives you jackpot, cash, and date of drawing, so those are all correctly linked. And that is what I am recording, date of drawing, not date of screenshot.)

Method: clicked through at least one screenshot on each month, in the years 2021 to 2017 (only up to October 31, when rules changed). Not every month, while having a screen shot had a unique drawing value. So just, noted where there was a unique drawing value. And noted that. Not perfectly rigorously. Fully rigorous method could do a full scrape from here.

### 4.1. enter data

```{r}
cash <-
rbind(
c(25e6, 18.6e6, "2021-01-29"),
c(20e6, 14.7e6, "2021-01-26"),
c(850e6, 628.2e6, "2021-01-19"),
c(510e6, 377.4e6, "2021-01-08"),
c(401e6, 305.4e6, "2021-01-01"),
c(310e6, 238e6, "2020-12-18"),
c(57e6, 45.4e6, "2020-08-25"),
c(22e6, 18e6, "2020-08-07"),
c(101e6, 76.5e6, "2020-03-24"),
c(65e6, 48.6e6, "2020-03-03"),
c(202e6, 142e6, "2020-02-11"),
c(266e6, 182.3e6, "2019-12-03"),
c(418e6, 263.3e6, "2019-05-28"),
c(316e6, 195.5e6, "2019-05-14"),
c(305e6, 181e6, "2018-12-18"),
c(208e6, 119e6, "2018-12-04"),
c(122e6, 69e6, "2018-11-16"),
c(106e6, 59e6, "2018-11-13"),
c(90e6, 50e6, "2018-11-09"),
c(52e6, 29e6, "2018-11-02"),
c(40e6, 22e6, "2018-10-26"),
c(45e6, 25e6, "2018-10-30"),
c(1600e6, 913e6, "2018-10-23"),
c(1000e6, 565e6, "2018-10-19"),
c(470e6, 265e6, "2018-10-09"),
c(405e6, 235e6, "2018-10-05"),
c(367e6, 213e6, "2018-10-02"),
c(252e6, 148e6, "2018-09-18"),
c(187e6, 111e6, "2018-09-07"),
c(88e6, 52e6, "2018-08-17"),
c(50e6, 29e6, "2018-08-03"),
c(306e6, 185e6, "2018-07-10"),
c(144e6, 85e6, "2018-06-12"),
c(84e6, 49e6, "2018-05-29"),
c(143e6, 84e6, "2018-05-04"),
c(80e6, 47e6, "2018-04-20"),
c(40e6, 24e6, "2018-04-03"),
c(502e6, 301e6, "2018-03-30"),
c(318e6, 187e6, "2018-03-13"),
c(290e6, 172e6, "2018-03-09"),
c(243e6, 143e6, "2018-03-02"),
c(204e6, 120e6, "2018-02-23"),
c(185e6, 109e6, "2018-02-20"),
c(136e6, 81e6, "2018-02-09"),
c(63e6, 38e6, "2018-01-23"),
c(50e6, 30e6, "2018-01-16"),
c(40e6, 25e6, "2018-01-09"),
c(361e6, 225e6, "2018-01-02"),
c(306e6, 191e6, "2017-12-29"),
c(277e6, 172e6, "2017-12-26"),
c(247e6, 155e6, "2017-12-22"),
c(208e6, 130e6, "2017-12-15"),
c(160e6, 100e6, "2017-12-05"),
c(145e6, 91e6, "2017-12-01"),
c(106e6, 66e6, "2017-11-21"),
c(82e6, 51e6, "2017-11-14"),
c(71e6, 44e6, "2017-11-10"),
c(59e6, 36e6, "2017-11-07"),
c(48e6, 29e6, "2017-11-03")
)


```

### 4.2. reshape data

```{r}
# name columns
colnames(cash) <- c("advertised", "cash", "date")

# reshape data
cash <-
data.frame(cash) %>% 
  mutate(advertised = as.integer(advertised),
         cash = as.integer(cash),
         date = as.Date(date),
         perc = cash/advertised*100)

# view data
cash

```

### 4.3. graph

```{r, fig.height=7, fig.width=12}
coeff <- max(cash$advertised)/max(cash$perc)
color_advertised <- "dodgerblue4"
color_perc <- "black"

plot_4 <-
cash %>% 
ggplot(aes(x = date)) +
  geom_line(aes(y = advertised),
            color = color_advertised,
            size = 2,
            alpha = 0.5) +
  geom_point(aes(y = perc * coeff),
             color = color_perc) +
  geom_line(aes(y = perc * coeff),
            color = color_perc,
            size = 1,
            alpha = 0.5) +
  scale_x_date(name = "Date",
               date_labels = "%Y (%b)",
               date_breaks = "1 month") +
  scale_y_continuous(labels = scales::label_dollar(),
                     breaks = c(0, 1:17*100e6),
                     name = "Advertised Jackpot Value (Annuity)",
                     sec.axis = sec_axis(trans = ~.*(1/coeff),
                                       name = "Cash Value (as % of Advertised Jackpot)",
                                       breaks = seq(0, 100, 10))) +
  labs(title = "Advertised Jackpot Size & Cash Value of Jackpot, Over Time") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.y.left = element_text(color = color_advertised, size = 10),
        axis.title.y.left = element_text(color = color_advertised),
        axis.title.y.right = element_text(margin = margin(t = 0, r = 0, b = 0, l = 10)),
        axis.text.x = element_text(angle = 90),
        panel.grid.minor = element_blank())

plot_4



```
### 4.3. save

```{r}
ggsave(plot = plot_4,
       filename = "cash_jackpot.pdf",
       width = 15,
       height = 7)
```

### 4.4. quantiles

```{r}
quantile(x = cash$perc,
         probs = c(0.01, 0.05, 0.1, 0.25, 0.50, 0.75, 0.90, 0.95, 0.99))
```
### 4.5. median, each year

```{r}
cash %>% 
  mutate(year = year(date)) %>% 
  group_by(year) %>% 
  summarise(median = median(perc))
```

### 4.6. SET: cash value %

This is where I will set coefficient (proportion) to multiply advertised (annuity) jackpot values by.
Since I don't have the same number of observations for every year, I will just take the mean of the median cash percent for each year.


```{r}
cash_perc <-
  cash %>% 
    mutate(year = year(date)) %>% 
    group_by(year) %>% 
    summarize(median = median(perc)) %>% 
    summarize(mean_median = mean(median))
cash_perc

cash_coeff <- cash_perc$mean_median/100
cash_coeff

```

## 4.7. net present value calculator

this is a function to calculate net present values
- source: https://www.investopedia.com/terms/n/npv.asp

```{r}
total <- 0
start <- (1/4)*1.5e6

for (year in 0:29){
  
  # annuity value
  print(paste0("year: ", year))
  print(paste0("payout: ", start * 1.05^year))
  total <- total + (start * 1.05^year)
  print(paste0("total: ", total))
  
  print("-------------")
  
}
```

# 5. Taxes

## 5.1. function: federal taxes

- source: https://www.nerdwallet.com/article/taxes/federal-income-tax-brackets
- source: https://www.irs.gov/newsroom/irs-provides-tax-inflation-adjustments-for-tax-year-2020

```{r}
# recursive function to calculate taxes
fed_taxes <- function(income){

  if (income <= 0) {
    return(0)
  }
  if (income > 518400){
    return(0.37 * (income - 518400) + fed_taxes(518400))
  }
  if (income <= 518400 & income > 207350){
    return(0.35 * (income - 207350) + fed_taxes(207350))
  }
  if (income <= 207350 & income > 163300){
    return(0.32 * (income - 163300) + fed_taxes(163300))
  }
  if (income <= 163300 & income > 85525){
    return(0.24 * (income - 85525) + fed_taxes(85525)) 
  }
  if (income <= 85525 & income > 40125){
    return(0.22 * (income - 40125) + fed_taxes(40125))
  }
  if (income <= 40125 & income > 9875){
    return(0.12 * (income - 9875) + fed_taxes(9875))
  }
  if (income <= 9875 & income > 0){
    return(0.10 * income)
  }
}

```

## 5.1. test

```{r}
fed_taxes(-100)
fed_taxes(0)
fed_taxes(1)
fed_taxes(9874)
fed_taxes(9875)
fed_taxes(9876)
fed_taxes(40124)
fed_taxes(40125)
fed_taxes(40126)
fed_taxes(85524)
fed_taxes(85525)
fed_taxes(85526)
fed_taxes(163299)
fed_taxes(163300)
fed_taxes(163301)
fed_taxes(207349)
fed_taxes(207350)
fed_taxes(207351)
fed_taxes(518399)
fed_taxes(518400)
fed_taxes(518401)
fed_taxes(1e6)
fed_taxes(10e6)
fed_taxes(100e6)
fed_taxes(1000e6)

fed_taxes(50e3)
fed_taxes(100e3)
```

## 5.2. function: state taxes

- Going to implement tax rates from state with highest income taxes (CA)
- source: https://turbotax.intuit.com/tax-tips/fun-facts/states-with-the-highest-and-lowest-taxes/L6HPAVqSF 
- source: https://www.nerdwallet.com/article/taxes/california-state-tax 
- source: https://smartasset.com/taxes/california-tax-calculator 

```{r}
# recursive function to calculate taxes
state_taxes <- function(income){

  if (income <= 0) {
    return(0)
  }
  if (income > 1e6){
    return((0.123+0.01) * (income - 1e6) + state_taxes(1e6))
  }
  if (income <= 1e6 & income > 599012){
    return(0.123 * (income - 599012) + state_taxes(599012))
  }
  if (income <= 599012 & income > 359407){
    return(0.113 * (income - 359407) + state_taxes(359407))
  }
  if (income <= 359407 & income > 299508){
    return(0.103 * (income - 299508) + state_taxes(299508))
  }
  if (income <= 299508 & income > 58634){
    return(0.093 * (income - 58634) + state_taxes(58634))
  }
  if (income <= 58634 & income > 46394){
    return(0.08 * (income - 46394) + state_taxes(46394))
  }
  if (income <= 46394 & income > 33421){
    return(0.06 * (income - 33421) + state_taxes(33421))
  }
  if (income <= 33421 & income > 21175){
    return(0.04 * (income - 21175) + state_taxes(21175))
  }
  if (income <= 21175 & income > 8932){
    return(0.02 * (income - 8932) + state_taxes(8932))
  }
  if (income <= 8932 & income > 0){
    return(0.01 * income)
  }

}

```

## 5.2. test

```{r}
state_taxes(-10)
state_taxes(0)
state_taxes(8931)
state_taxes(8932)
state_taxes(8933)
state_taxes(46394)
state_taxes(586354)
state_taxes(599011)
state_taxes(599012)
state_taxes(599013)
state_taxes(1e6)
state_taxes(10e6)
state_taxes(100e6)
state_taxes(1000e6)

state_taxes(87701-4601)
```
# X. Other Prizes

The goal here is to calculate the expected value of the others prizes in the lottery

-- odds for smaller prizes can be found here (1) https://www.megamillions.com/how-to-play, and (2) calculations can be found here http://www.durangobill.com/MegaMillionsOdds.html (actually the latter are more exact)

```{r}
# total possible ticket combinations
tick_combos <- choose(n = 70, k = 5) * 25

# odds of winning each of the smaller prizes
odds_5.0 <- choose(n = 5, k = 5) * choose(n = 24, k = 1) / tick_combos                          # ~(1/12607306)
odds_4.1 <- choose(n = 5, k = 4) * choose(n = 65, k = 1) * choose(n = 1, k = 1)  / tick_combos  # ~(1/931001)
odds_4.0 <- choose(n = 5, k = 4) * choose(n = 65, k = 1) * choose(n = 24, k = 1) / tick_combos  # ~(1/38792)
odds_3.1 <- choose(n = 5, k = 3) * choose(n = 65, k = 2) * choose(n = 1, k = 1)  / tick_combos  # ~(1/14547)
odds_3.0 <- choose(n = 5, k = 3) * choose(n = 65, k = 2) * choose(n = 24, k = 1) / tick_combos  # ~(1/606)
odds_2.1 <- choose(n = 5, k = 2) * choose(n = 65, k = 3) * choose(n = 1, k = 1)  / tick_combos  # ~(1/693)
odds_1.1 <- choose(n = 5, k = 1) * choose(n = 65, k = 4) * choose(n = 1, k = 1)  / tick_combos  # ~(1/89)
odds_0.1 <- choose(n = 5, k = 0) * choose(n = 65, k = 5) * choose(n = 1, k = 1)  / tick_combos  # ~(1/37)

# calculate additional expected value of ticket, from small prizes
# method 1. without taxes
other_prizes <- 1e6  * odds_5.0 +
                10e3 * odds_4.1 +
                500  * odds_4.0 +
                200  * odds_3.1 +
                10   * odds_3.0 +
                10   * odds_2.1 +
                4    * odds_1.1 +
                2    * odds_0.1

other_prizes

# method 2. with taxes
other_prizes_taxes <- (1e6  - fed_taxes(1e6)  - state_taxes(1e6))  * odds_5.0 +
                      (10e3 - fed_taxes(10e3) - state_taxes(10e3)) * odds_4.1 +
                      (500  - fed_taxes(500)  - state_taxes(500))  * odds_4.0 +
                      (200  - fed_taxes(200)  - state_taxes(200))  * odds_3.1 +
                      (10   - fed_taxes(10)   - state_taxes(10))   * odds_3.0 +
                      (10   - fed_taxes(10)   - state_taxes(10))   * odds_2.1 +
                      (4   - fed_taxes(4)   - state_taxes(4))      * odds_1.1 +
                      (2   - fed_taxes(2)   - state_taxes(2))      * odds_0.1

other_prizes_taxes

```


# Y. Jackpot Size v. Expect Value

The expected value is a function of:
- net present value (cash value of prize)
- taxes (federal & state)
- number of tickets sold

Here, I try to identify how each of these affect the expected value of a ticket. And then graph those effeccts

## Y.1. EV as f(jackpot, # ticks)

The goal here is to compute and then graph expected value of a ticket (EV) as function of:
-- jackpot value
-- number of tickets sold
-- whether the pot will be split, in the case of multiple winners

### Y.1.1. compute: EV, w/ splitting & no splitting

-- must also select max # winners to cycle through (picked: 100)
-- note: will compute
---- 1. ev: expected value, just including jackpot
---- 2. ev_full: expected value, including smaller jackpots as well
---- 3. ev_basic: expected value, if you buy tickets systematically (not randomly pick) [not fully computed out]


```{r}
# preset value, to loop through & use
jackpots <- c(1, 1e3, 1e6, 10e6, 20e6, 40e6, 50e6, 75e6, 100e6, 125e6, 150e6, 175e6, 200e6, 300e6, 400e6, 500e6, 750e6, 1e9, 1.5e9, 2e9, 5e9, 10e9)
tickets <- c(1, 10, 1e3, 10e3, 100e3, 1e6, 10e6, 15e6, 20e6, 25e6, 30e6, 35e6, 40e6, 50e6, 100e6, 200e6, 500e6, 750e6, 1e9, 2e9, 5e9, 10e9)
max_winners <- 100
splits <- c(TRUE, FALSE)
total_EVs <- length(jackpots) * length(tickets) * length(splits)
total_EVs

# data frame, to save results
EV <- data.frame(jackpot = integer(total_EVs),
                 tickets = integer(total_EVs),
                 split = logical(total_EVs),
                 ev_jj = double(total_EVs),
                 ev_full = double(total_EVs),
                 ev_full_cash = double(total_EVs),
                 ev_full_taxes = double(total_EVs))

# loop and calculate all possible EVs
i <- 0
for (jackpot_i in jackpots){
  for (tickets_i in tickets){
    for (split_i in splits){
      i <- i + 1
      EV$jackpot[i] <- jackpot_i
      EV$tickets[i] <- tickets_i
      EV$split[i] <- split_i
      EV$ev_jj[i] <- ev_split(jackpot = jackpot_i,
                             tickets = tickets_i,
                             max_winners = max_winners,
                             prob_win = (1/302575350),
                             method = "sum",
                             split = split_i)
      EV$ev_full[i] <- EV$ev_jj[i] + other_prizes
      EV$ev_full_cash[i] <- ev_split(jackpot = jackpot_i * cash_coeff,
                                tickets = tickets_i,
                                max_winners = max_winners,
                                prob_win = (1/302575350),
                                method = "sum",
                                split = split_i) + other_prizes
      EV$ev_full_taxes[i] <- ev_split(jackpot = (jackpot_i * cash_coeff) - fed_taxes(jackpot_i * cash_coeff) - state_taxes(jackpot_i * cash_coeff),
                                tickets = tickets_i,
                                max_winners = max_winners,
                                prob_win = (1/302575350),
                                method = "sum",
                                split = split_i) + other_prizes_taxes
    }
  }
}


```
```{r}
EV
```

## Y.2. graph: Theoretical EVs

```{r, fig.width=12, fig.height=10}
EV_long <-
EV %>% 
  pivot_longer(cols = c("ev_full", "ev_full_cash", "ev_full_taxes"),
               names_to = "type",
               values_to = "ev") %>% 
  mutate(tickets = factor(tickets,
                          levels = c(1, 10, 1e3, 10e3, 100e3, 1e6, 10e6, 15e6, 20e6, 25e6, 30e6, 35e6, 40e6, 50e6, 100e6, 
                                      200e6, 500e6, 750e6, 1e9, 2e9, 5e9, 10e9),
                          labels = c("1", "10", "1k", "10k", "100k", "1m", "10m", "15m", "20m", "25m", "30m", "35m", "40m", "50m", "100m",
                                     "200m", "500m", "750m", "1b", "2b", "5b", "10b")),
         jackpot = factor(jackpot,
                          levels = c(1, 1e3, 1e6, 10e6, 20e6, 40e6, 50e6, 75e6, 100e6, 125e6, 150e6, 175e6, 200e6, 300e6,
                                     400e6, 500e6, 750e6, 1e9, 1.5e9, 2e9, 5e9, 10e9),
                          labels = c("1", "1k", "1m", "10m", "20m", "40m", "50m", "75m", "100m", "125m", "150m", "175m", "200m", "300m",
                                     "400m", "500m", "750m", "1b", "1.5b", "2b", "5b", "10b")),
         split = fa
         ev_print = round(ev, 2),
         sign = case_when(ev_print <2   ~ "negative",
                          ev_print == 2 ~ "zero",
                          ev_print >2   ~ "positive"),
         sign = as.factor(sign))

EV_long %>% 
  ggplot(aes(x = tickets,
             y = jackpot,
             fill = sign,
             label = ev_print)) +
  geom_raster(alpha = 0.35 + 0.65*(EV_long$ev_print - min(EV_long$ev_print))/max(EV_long$ev_print)) +   #0.5) +
  geom_text(color = "white",
            size = 2) +
  geom_rect(aes(ymin = 5  - 0.5,  #which(jackpots %in% 20e6),
                ymax = 19 + 0.5, #which(jackpots %in% 1.5e9),
                xmin = 8  - 0.5,  #which(tickets %in% 15e6),
                xmax = 18 + 0.5, #which(tickets %in% 750e6),
                fill = NA),
                color = "white") +
  scale_fill_manual(values = c("red", "green", "grey")) +
  labs(x = "Ticket Sales",
       y = "Jackpot Size ($)",
       title = "Expected Value of Lottery Ticket ($)") +
  guides(fill = FALSE) +
  facet_grid(type ~ split) +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90,
                                   vjust = 0.25),
        axis.text.y = element_text(vjust = 0.25),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

```


# ### WORKSPACE ###
```{r}
quantile(x = round(lott_clean$sales/1e6), probs = c(0, 0.01, 0.05, 0.1, 0.20, 0.25, 0.30, 0.40, 0.50, 0.60, 0.70, 0.75, 0.80, 0.9, 0.95, 0.99, 1))
print("------------------------------------------------")
quantile(x = round(lott_clean$jackpot/1e6), probs = c(0, 0.01, 0.05, 0.1, 0.20, 0.25, 0.30, 0.40, 0.50, 0.60, 0.70, 0.75, 0.80, 0.9, 0.95, 0.99, 1))
```
# ### WORKSPACE ###

# X. Model

## Xa. Model 1 (y = sales, x = jackpot)

```{r}
m1 <- lm(data = lott_clean,
         formula = sales ~ jackpot)

summary(m1)

```
## Xb.Correlation (sales & jackpot)

```{r}
cor(lott_clean$sales, lott_clean$jackpot)
```


# MISC/END